 当不可预测性至关重要时，如大多数对安全性要求较高的环境都采用随机性，这时可以使用密码学的 PRNG。不管选择了哪一种 PRNG，都要始终使用带有充足熵的数值作为该算法的种子。（诸如当前时间之类的数值只提供很小的熵，因此不应该使用。） 
Java 语言在  java.security.SecureRandom 中提供了一个加密 PRNG。就像  java.security 中其他以算法为基础的类那样， SecureRandom 提供了与某个特定算法集合相关的包，该包可以独立实现。当使用  SecureRandom.getInstance() 请求一个  SecureRandom 实例时，您可以申请实现某个特定的算法。如果算法可行，那么您可以将它作为  SecureRandom 的对象使用。如果算法不可行，或者您没有为算法明确特定的实现方法，那么会由系统为您选择  SecureRandom 的实现方法。  
Sun 在名为  SHA1PRNG 的 Java 版本中提供了一种单独实现  SecureRandom 的方式，Sun 将其描述为计算： 
“SHA-1 可以计算一个真实的随机种子参数的散列值，同时，该种子参数带有一个 64 比特的计算器，会在每一次操作后加 1。在 160 比特的 SHA-1 输出中，只能使用 64 比特的输出 [1]。”  
然而，文档中有关 Sun 的  SHA1PRNG 算法实现细节的相关记录很少，人们无法了解算法实现中使用的熵的来源，因此也并不清楚输出中到底存在多少真实的随机数值。尽管有关 Sun 的实现方法网络上有各种各样的猜测，但是有一点无庸置疑，即算法具有很强的加密性，可以在对安全性极为敏感的各种内容中安全地使用。  
